# First attempt at modeling EBNF modeling my custom DSL

@@grammar :: GameDSL
@@parseinfo :: True

start = '(define' game_def domain_def setup_def constraints_def terminal_def scoring_def ')' $;
game_def = '(game' game_name:id ')';
domain_def = '(:domain' domain_name:id ')';
setup_def = '(:setup' setup ')';
constraints_def = '(:constraints' preferences ')';
terminal_def = '(:terminal' terminal ')' | ();  # TODO: do we want this to be optional?
scoring_def = '(:scoring' scoring ')';

# Generic definitions useful across sections

id = /[a-z]+(-[a-z0-9]+)*/;
name = /[A-z]+(_[A-z0-9]+)*/;
number = /\d*\.?\d+/;

variable = /\?[a-z][a-z0-9]*/;
variable_list = '(' variables:{variable_type_def}+ ')';
variable_type_def = var_names:{variable}+ '-' var_type:type_defition;
type_defition = name | either_types;
either_types = '(either' {type_names:name}+ ')'; # TODO: do we want to enforce more than one?
    

function_comparison = 
    '(' comp_op:binary_comp comp_func_1:function_eval comp_func_2:function_eval ')' |
    '(' comp_op:binary_comp comp_func_first:function_eval comp_num:number ')' |
    '(' comp_op:binary_comp comp_num:number comp_func_second:function_eval ')' |
    '(' '=' {equal_comp_funcs:function_eval}+ ')' 
    ;
# function_comparison = fc1 | fc2 | fc3 | fc4;
# fc1 = '(' binary_comp function_eval function_eval ')';
# fc2 = '(' binary_comp function_eval number ')';
# fc3 = '(' binary_comp number function_eval ')';
# fc4 = '(' '=' {function_eval}+ ')' ;
binary_comp = '<=' | '<' | '=' | '>=' | '>';
function_eval = '(' func_name:name func_args:{function_term}* ')';
function_term = name | variable | number;

predicate = '(' pred_name:predicate_name pred_args:{predicate_term}* ')';
predicate_name = '=' | name;  # = here to allow for checking that one object is/isn't another
# predicate_term = name | variable | predicate:predicate;
predicate_term = name | variable | predicate;
# predicate_function = predicate;

# Game Setup

setup = setup_and |
    setup_or |
    setup_not |
    setup_exists |
    setup_forall |
    setup_statement |
    ()
    ;
    
setup_and = '(and' {and_args:setup}+ ')';  # TODO: do we want to enforce more than one?
setup_or = '(or' {or_args:setup}+ ')';  # TODO: do we want to enforce more than one?
setup_not = '(not' not_args:setup ')';
setup_exists = '(exists' exists_vars:variable_list exists_args:setup ')';
setup_forall = '(forall' forall_vars:variable_list forall_args:setup ')';
    
setup_statement = setup_game_conserved | setup_game_optional;
    
setup_game_conserved = '(game-conserved' {conserved_pred:setup_predicate}+ ')';
setup_game_optional = '(game-optional' {optional_pred:setup_predicate}+ ')';

setup_predicate = 
    setup_and_predicate |
    setup_or_predicate |
    setup_not_predicate | 
    function_comparison |
    predicate
    ;
    
setup_and_predicate = '(and' {and_args:setup_predicate}+ ')'; # TODO: do we want to enforce more than one?
setup_or_predicate = '(or' {or_args:setup_predicate}+ ')';  # TODO: do we want to enforce more than one?
setup_not_predicate = '(not' not_args:setup_predicate ')';

# Constraints/Preferences
preferences = preference | 
    '(and' {preference}+ ')'; # TODO: do we want to enforce more than one?

preference = '(preference' pref_name:name pref_body:pref_body ')';

pref_body = 
    pref_body_exists |
    pref_body_forall | 
    then |
    at_end 
    ;

pref_body_exists = '(exists' exists_vars:variable_list exists_args:pref_body ')';
pref_body_forall = '(forall' forall_vars:variable_list forall_args:pref_body ')';
at_end = '(at-end' at_end_pred:pref_predicate')';
then = '(then' {then_funcs:seq_funq}+ ')';

seq_funq = 
    any |
    once |
    once_measure |
    hold |
    while_hold |
    hold_for |
    hold_to_end |
    forall_seq 
    ;

any = '(any)';
once = '(once ' once_pred:pref_predicate ')';
once_measure = '(once-measure' once_measure_pred:pref_predicate measurement:function_eval ')';
hold = '(hold' hold_pred:pref_predicate ')';
while_hold = '(hold-while' hold_pred:pref_predicate {while_preds:pref_predicate}+ ')';
hold_for = '(hold-for' num_to_hold:number hold_pred:pref_predicate ')';
hold_to_end = '(hold-to-end' hold_pred:pref_predicate ')';
forall_seq = '(forall-sequence' forall_seq_vars:variable_list forall_seq_then:then ')'; 

pref_predicate = 
    pref_predicate_and |
    pref_predicate_or |
    pref_predicate_not |
    pref_predicate_exists |
    pref_predicate_forall |
    predicate |
    function_comparison 
    ;

pref_predicate_and = '(and' {and_args:pref_predicate}+ ')';  # TODO: do we want to enforce more than one?
pref_predicate_or = '(or' {or_args:pref_predicate}+ ')';  # TODO: do we want to enforce more than one?
pref_predicate_not = '(not' not_args:pref_predicate ')';
pref_predicate_exists = '(exists' exists_vars:variable_list exists_pred:pref_predicate ')';
pref_predicate_forall = '(forall' forall_vars:variable_list forall_pred:pref_predicate ')';

# Terminal conditions

terminal = 
    terminal_and |
    terminal_or |
    terminal_not |
    terminal_comp
    ;

terminal_and = '(and' {and_args:terminal}+ ')'; # TODO: do we want to enforce more than one?
terminal_or = '(or' {or_args:terminal}+ ')'; # TODO: do we want to enforce more than one?
terminal_not = '(not' not_args:terminal ')';
terminal_comp = '(' op:binary_comp expr_1:terminal_expr expr_2:terminal_expr ')';

# alternatively, if we don't want scoring to be able to refer to '(total-score)''
# we recreate the definition from above, and add '(total-score)' as a separate literal option 
terminal_expr = scoring_expr;

scoring_expr = 
    scoring_multi_expr |
    scoring_binary_expr |
    scoring_neg_expr |
    total_time |
    total_score |
    number |
    preference_eval |
    scoring_comparison |
    function_eval  # allowing an arbitrary function evaluation as part of scoring -- do we want this?
    ;

scoring_multi_expr = '(' op:multi_op {expr:scoring_expr}+ ')';  # TODO: do we want to enforce more than one?
scoring_binary_expr = '(' op:binary_op expr_1:scoring_expr expr_2:scoring_expr ')';
scoring_neg_expr = '(-' expr:scoring_expr ')';
total_time = '(total-time)';
total_score = '(total-score)' ;  # allowing to refer to it here to say, double the score if a condition is achieved

multi_op = '+' | '*';
binary_op = '-' | '/';

scoring_comparison = 
    scoring_comp |
    scoring_equals_comp;

scoring_comp = '(' op:binary_comp expr_1:scoring_expr expr_2:scoring_expr ')';
scoring_equals_comp = '(=' {expr:scoring_expr}+ ')';


preference_eval = 
    count_nonoverlapping |
    count_once |
    count_once_per_objects |
    count_longest |
    count_shortest |
    count_total |
    count_increasing_measure;

count_nonoverlapping = '(count-nonoverlapping' pref_name:name ')';
count_once = '(count-once' pref_name:name ')';
count_once_per_objects = '(count-once-per-objects' pref_name:name ')';
count_longest = '(count-longest' pref_name:name ')';
count_shortest = '(count-shortest' pref_name:name ')';
count_total = '(count-total' pref_name:name ')';
count_increasing_measure = '(count-increasing-measure' pref_name:name ')';

# Scoring
scoring = 
    scoring_maximize |
    scoring_minimize;
    
scoring_maximize = 'maximize' scoring_expr;
scoring_minimize = 'minimize' scoring_expr;
