# First attempt at modeling EBNF modeling my custom DSL

@@grammar :: GameDSL
@@parseinfo :: True
@@eol_comments :: /;([^\n]*?)$/

start = '(define' game_def domain_def setup_def constraints_def terminal_def scoring_def ')' $;
game_def = '(game' game_name:id ')';
domain_def = '(:domain' domain_name:id ')';
setup_def = '(:setup' setup ')' | ();
constraints_def = '(:constraints' preferences ')';
terminal_def = '(:terminal' terminal ')' | ();  # TODO: do we want this to be optional?
scoring_def = '(:scoring' scoring ')';

# Generic definitions useful across sections

id = /[a-z0-9]+(-[a-z0-9]+)*/;
name = /[A-z]+(_[A-z0-9]+)*/;
number = /\d*\.?\d+/;

variable = /\?[a-z][a-z0-9]*/;
variable_list = '(' {variables:variable_type_def}+ ')';
variable_type_def = {var_names:variable}+ '-' var_type:type_definition;
type_definition = type:(type_name | either_types);  # TODO: see if I need to add a name for this
either_types = '(either' {type_names:type_name}+ ')'; # TODO: do we want to enforce more than one?
type_name = name;

function_comparison = comp:(two_arg_comparison | multiple_args_equal_comparison);
two_arg_comparison = '(' comp_op:binary_comp arg_1:comparison_arg arg_2:comparison_arg ')';
multiple_args_equal_comparison = '(=' {equal_comp_args:comparison_arg}+ ')';

comparison_arg = arg:(function_eval | number);
binary_comp = '<=' | '<' | '=' | '>=' | '>';
function_eval = '(' func_name:func_name {func_args:function_term}* ')';
func_name = name;
function_term = term:(number | type_name | variable); 

predicate = '(' pred_name:predicate_name {pred_args:predicate_term}* ')';
predicate_name = name;  # = used to be here to allow for checking that one object is/isn't another
predicate_term = term:(type_name | variable);
# predicate_function = predicate;

# Game Setup

setup = setup:(setup_and |
    setup_or |
    setup_not |
    setup_exists |
    setup_forall |
    setup_statement
    ) 
    ;
    
setup_and = '(and' {and_args:setup}+ ')';  # TODO: do we want to enforce more than one?
setup_or = '(or' {or_args:setup}+ ')';  # TODO: do we want to enforce more than one?
setup_not = '(not' not_args:setup ')';
setup_exists = '(exists' exists_vars:variable_list exists_args:setup ')';
setup_forall = '(forall' forall_vars:variable_list forall_args:setup ')';
    
setup_statement = statement:(setup_game_conserved | setup_game_optional);
    
setup_game_conserved = '(game-conserved' conserved_pred:super_predicate ')';
setup_game_optional = '(game-optional' optional_pred:super_predicate ')';

super_predicate = pred:(
    super_predicate_and |
    super_predicate_or |
    super_predicate_not | 
    super_predicate_exists |
    super_predicate_forall |
    function_comparison |
    predicate
    )
    ;
    
super_predicate_and = '(and' {and_args:super_predicate}+ ')'; # TODO: do we want to enforce more than one?
super_predicate_or = '(or' {or_args:super_predicate}+ ')';  # TODO: do we want to enforce more than one?
super_predicate_not = '(not' not_args:super_predicate ')';
super_predicate_exists = '(exists' exists_vars:variable_list exists_args:super_predicate ')';
super_predicate_forall = '(forall' forall_vars:variable_list forall_args:super_predicate ')';

# Constraints/Preferences
preferences = 
    '(and' {preferences:pref_def}+ ')' | # TODO: do we want to enforce more than one?
    preferences:pref_def
    ;

pref_def = definition:(preference | pref_forall);

preference = '(preference' pref_name:preference_name pref_body:pref_body ')';
preference_name = name;
pref_forall = '(forall' forall_vars:variable_list forall_pref:pref_forall_prefs ')';

pref_forall_prefs = '(and' {preferences:preference}+ ')' |  # to allow multiple preferences in a forall
    {preferences:preference};

pref_body = body:(
    pref_body_exists |
    pref_body_forall | 
    then |
    at_end)
    ;

pref_body_exists = '(exists' exists_vars:variable_list exists_args:pref_body ')';
pref_body_forall = '(forall' forall_vars:variable_list forall_args:pref_body ')';
at_end = '(at-end' at_end_pred:super_predicate')';
# always = '(always' always_pred:super_predicate')';
then = '(then' {then_funcs:seq_func}+ ')';

seq_func = seq_func:(
    any |
    once |
    once_measure |
    hold |
    while_hold |
    hold_for |
    hold_to_end |
    forall_seq
    );

any = '(any)';
once = '(once ' once_pred:super_predicate ')';
once_measure = '(once-measure' once_measure_pred:super_predicate measurement:function_eval ')';
hold = '(hold' hold_pred:super_predicate ')';
while_hold = '(hold-while' hold_pred:super_predicate {while_preds:super_predicate}+ ')';
hold_for = '(hold-for' num_to_hold:number hold_pred:super_predicate ')';
hold_to_end = '(hold-to-end' hold_pred:super_predicate ')';
forall_seq = '(forall-sequence' forall_seq_vars:variable_list forall_seq_then:then ')'; 

# super_predicate = 
#     super_predicate_and |
#     super_predicate_or |
#     super_predicate_not |
#     super_predicate_exists |
#     super_predicate_forall |
#     predicate |
#     function_comparison 
#     ;

# super_predicate_and = '(and' {and_args:super_predicate}+ ')';  # TODO: do we want to enforce more than one?
# super_predicate_or = '(or' {or_args:super_predicate}+ ')';  # TODO: do we want to enforce more than one?
# super_predicate_not = '(not' not_args:super_predicate ')';
# super_predicate_exists = '(exists' exists_vars:variable_list exists_pred:super_predicate ')';
# super_predicate_forall = '(forall' forall_vars:variable_list forall_pred:super_predicate ')';

# Terminal conditions

terminal = terminal:(
    terminal_and |
    terminal_or |
    terminal_not |
    terminal_comp
    );

terminal_and = '(and' {and_args:terminal}+ ')'; # TODO: do we want to enforce more than one?
terminal_or = '(or' {or_args:terminal}+ ')'; # TODO: do we want to enforce more than one?
terminal_not = '(not' not_args:terminal ')';
terminal_comp = '(' op:binary_comp expr_1:terminal_expr expr_2:terminal_expr ')';

# alternatively, if we don't want scoring to be able to refer to '(total-score)''
# we recreate the definition from above, and add '(total-score)' as a separate literal option 
terminal_expr = expr:scoring_expr;

scoring_expr = expr:(
    scoring_external_maximize |
    scoring_external_minimize |
    scoring_multi_expr |
    scoring_binary_expr |
    scoring_neg_expr |
    scoring_and |
    scoring_or |
    scoring_not |
    total_time |
    total_score |
    number |
    preference_eval |
    scoring_comparison 
    );
    # function_eval  # allowing an arbitrary function evaluation as part of scoring -- why do we want this?
    

scoring_external_maximize = '(external-forall-maximize' scoring_expr:scoring_expr ')';
scoring_external_minimize = '(external-forall-minimize' scoring_expr:scoring_expr ')';

scoring_multi_expr = '(' op:multi_op {expr:scoring_expr}+ ')';  # TODO: do we want to enforce more than one?
scoring_binary_expr = '(' op:binary_op expr_1:scoring_expr expr_2:scoring_expr ')';
scoring_neg_expr = '(-' expr:scoring_expr ')';

scoring_and = '(and' {and_args:scoring_expr}+ ')'; # TODO: do we want to enforce more than one?
scoring_or = '(or' {or_args:scoring_expr}+ ')'; # TODO: do we want to enforce more than one?
scoring_not = '(not' not_args:scoring_expr ')';


total_time = '(total-time)';
total_score = '(total-score)' ;  # allowing to refer to it here to say, double the score if a condition is achieved

multi_op = '+' | '*';
binary_op = '-' | '/';

scoring_comparison = comp:(
    scoring_comp |
    scoring_equals_comp);

scoring_comp = '(' op:binary_comp expr_1:scoring_expr expr_2:scoring_expr ')';
scoring_equals_comp = '(=' {expr:scoring_expr}+ ')';


preference_eval = count_method:(
    count |
    count_overlapping |
    count_once |
    count_once_per_objects |
    count_longest |
    count_shortest |
    count_total |
    count_increasing_measure |
    count_unique_positions |
    count_same_positions |
    # count_maximal_once |
    # count_maximal_once_per_objects |
    # count_maximal_nonoverlapping | 
    # count_maximal_overlapping |
    count_once_per_external_objects |
    count_measure
    );

count = '(count' name_and_types:pref_name_and_types ')';
count_overlapping = '(count-overlapping' name_and_types:pref_name_and_types ')';
count_once = '(count-once' name_and_types:pref_name_and_types ')';
count_once_per_objects = '(count-once-per-objects' name_and_types:pref_name_and_types ')';
count_longest = '(count-longest' name_and_types:pref_name_and_types ')';
count_shortest = '(count-shortest' name_and_types:pref_name_and_types ')';
count_total = '(count-total' name_and_types:pref_name_and_types ')';
count_increasing_measure = '(count-increasing-measure' name_and_types:pref_name_and_types ')';
count_unique_positions = '(count-unique-positions' name_and_types:pref_name_and_types ')';
count_same_positions = '(count-same-positions' name_and_types:pref_name_and_types ')';
# count_maximal_once = '(count-maximal-once' name_and_types:pref_name_and_types ')';
# count_maximal_once_per_objects = '(count-maximal-once-per-objects' name_and_types:pref_name_and_types ')';
# count_maximal_nonoverlapping = '(count-maximal-nonoverlapping' name_and_types:pref_name_and_types ')';
# count_maximal_overlapping = '(count-maximal-overlapping' name_and_types:pref_name_and_types ')';
count_once_per_external_objects = '(count-once-per-external-objects' name_and_types:pref_name_and_types ')';
count_measure = '(count-measure' name_and_types:pref_name_and_types ')';

pref_name_and_types = pref_name:preference_name {object_types:pref_object_type}*;

pref_object_type = ':' type_name:type_name;

# Scoring
scoring = scoring_expr;
    
# scoring_maximize = 'maximize' expr:scoring_expr;
# scoring_minimize = 'minimize' expr:scoring_expr;
